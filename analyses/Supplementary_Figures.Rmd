---
title: "Supplementary Figures"
author: "Rachael Caelie (Rocky) Aikens"
date: "5/8/2019"
output: pdf_document
---

```{r setup, warning=FALSE, message = FALSE, include = FALSE}
knitr::opts_chunk$set(cache=TRUE, warning = FALSE, message = FALSE, echo = FALSE, fig.align = "center", fig.height = 4)
require(ggplot2)
require(dplyr)
require(gridExtra)
require(ggpubr)
theme_set(theme_light())
source("../code/basic_sim_functions.R")
```

# To do

- [ ] Supplementary figure 3 (p = 50)

# Supplementary Figure 1

```{r}
match_viz <- function(data, match, rho, k = 1, title = "Matching"){
  plt_data <- data %>% 
    mutate(m = match) %>%
    mutate(a = ifelse (is.na(m), 0.9, 1)) %>% 
    mutate(prog = rho*X1 + sqrt(1-rho^2)*X2, 
           prop = mu,
           t = as.factor(abs(1-t))) %>%
    select(c(t, prog, prop, m, a))
  
  m_data <- plt_data %>% 
    filter(!is.na(m)) %>%
    arrange(m, desc(t)) %>% 
    mutate(id = rep(1:(k + 1), sum(data$t))) %>%
    select(-c(t, a)) %>%
    group_by(m) %>%
    summarize(prop1 = first(prop), prop2 = last(prop),
              prog1 = first(prog), prog2 = last(prog)) %>%
    select(prog1, prog2, prop1, prop2)
  
  plt <- ggplot(data = plt_data, aes( x = prop, y = prog, group = t, color = t)) + 
    geom_point(aes(alpha = a))+
    scale_color_brewer(palette="Set1") +
    geom_segment(data = m_data, 
                 aes(x = prop1, y = prog1,
                     xend = prop2, yend = prog2),
                 color =  "black", group = NA, linetype = "dashed") +
    ggtitle( title)+
    theme(legend.position = "none", aspect.ratio=1, plot.title = element_text(hjust = 0.5, size = 8))+
    ylab(expression(paste(Psi, "(x)", sep = ""))) +
    xlab(expression(paste(phi, "(x)", sep = "")))
  
  return(plt)
}

overlap_histogram <- function(data){
    plt_data <- data %>% 
      mutate(prog = rho*X1 + sqrt(1-rho^2)*X2, 
           prop = mu,
           t = as.factor(abs(1-t))) %>%
      select(c(t, prog, prop))
    
    ggplot(plt_data, aes(x = prop, fill = t)) + geom_histogram(alpha = 0.4, position = "identity")
}

# like prognostic match except returns data frame and match assignments, not just the
# reformatted dataframe of outcomes by match assignment
prognostic_match_assignment <- function(df, propensity, match_assignment, prog_model, n_control) {
  df$m <- match_assignment
  df$row <- 1:nrow(df)
  n_t<- sum(df$t)

  selected <- df %>% 
    filter(!is.na(m)) %>%
    filter(t==0) %>%
    group_by(m) %>%
    sample_n(size = 1)
  
  prognostic <- lm(y ~ . - mu - t - row - m, data = selected)
  not_selected <- df[-selected$row, ]
  not_selected <- not_selected %>% 
			mutate(progscore = predict(prognostic, not_selected)) %>%
			mutate(propscore = predict(propensity, not_selected))
  prog_dist <- match_on(t ~ progscore + propscore, data = not_selected)
  prog_match <- pairmatch(prog_dist, controls = n_control, data = not_selected) 
  return(list(df = not_selected, match = prog_match, k = n_control))
}
```

```{r}
rho <- 0.9
#simulate data
df <- generate_data(N = 2000, p = 10, true_mu = "X1-10/3", rho = rho, sigma = 1)
k = 1
prop_model = formula(t ~ . - mu - y)
prog_model = formula(y ~ . - mu - t)

# mahalanobis match
mahal_dist <- match_on(prop_model, method = "mahalanobis", data = df)
m_match <- pairmatch(mahal_dist, controls = k, df)
```


```{r}
# Build scores empirically for propensity and prognostic match

# build propensity score
propensity <- glm(prop_model, family = binomial(), data = df)
  
prop_match <- pairmatch(propensity, controls = k, df)
  
# 1:2 mahalanobis matching to select data to use for prognostic model
mahal_match <- pairmatch(mahal_dist, controls = 2, df) 
  
buff_match_assignment <- prognostic_match_assignment(df, propensity, mahal_match, prog_model, k)
```


```{r}
#Calculate true propensity and prognostic score, and match on the true score
oracle_df <- df %>% 
    mutate(prog = rho*X1 + sqrt(1-rho^2)*X2, 
           prop = 1/(1+exp(-(mu))))

oracle_prop_match <- pairmatch(t ~ prop, controls = k, oracle_df)
oracle_prog_match <- pairmatch(t ~ prog + prop, controls = k, oracle_df)
```

```{r, fig.width=8.5, fig.height= 3.5}
a <- match_viz(df, m_match, rho, title = "Mahalanobis")
b <- match_viz(df, oracle_prop_match, rho, title = "True Propensity")
c <- match_viz(df, oracle_prog_match, rho, title = "True Propensity x Prognosis")

ggarrange(a,b,c, ncol= 3, labels = "AUTO")
```

**Supplementary Figure 1:** Replication of Figure 1 with $\rho = 0.9$.  This simulates the case that propensity and prognosis are highly correllated. When this occurs, matching on propensity will also achieve some prognostic balance, and vise-versa. All simulation parameters are as described in section 2.1.

# Supplementary Figure 2


```{r, fig.width = 8.5, fig.height = 3.5}
a <- match_viz(df, m_match, rho, title = "Mahalanobis")
b <- match_viz(df, prop_match, rho, title = "Estimated Propensity")
c <- match_viz(buff_match_assignment$df, buff_match_assignment$match, rho, title = "Buffalo")

ggarrange(a, b, c, ncol = 3, labels = "AUTO")
```
**Supplementary Figure 1:** Replication of Figure 2 with $\rho = 0.9$.  All simulation parameters are as described in section 2.1.


# Supplementary Figure 3

```{r}
read_data_1000 <- function(i, path_to_file){
  filename <- paste(path_to_file, "angle_sigma1_results_",i,"_10_1000", sep = "")
  dat <- read.csv(filename) %>%
    mutate(rho = i/10)
  return(dat)
}
```


Bias and MSE for MDM, propensity, and prognostic score matching when p = 50.

To do

# Supplementary Figure 4

```{r}
dat <- lapply(1:10, function(x) read_data_1000(x, "../data/mu_x1_minus_10_3rds/nsim_1000/")) %>% bind_rows
```

```{r}
true_tau <- 1

dat <- dat %>% mutate(
              squared_err = (estimate-true_tau)**2,
              k = as.factor(k))

plt_data <- dat %>%
  group_by(method, k, rho) %>% 
  summarize(Bias = abs(mean(estimate) - true_tau), 
            median_gamma = median(gamma), 
            Standard.Deviation = sd(estimate),
            MSE = Bias^2 + Standard.Deviation^2) %>%
  ungroup() %>%
  mutate(method = recode(method, propensity = "Propensity", 
                         mahalanobis = "Mahalanobis", 
                         prognostic = "Buffalo"))
```

```{r, echo = FALSE}
plt_data <- plt_data %>%
  mutate(method = factor(method, levels = c("Mahalanobis", "Propensity", "Buffalo")))
```

```{r, fig.width=8.5, fig.height=3, echo = FALSE}
b <- ggplot(plt_data, aes(x = rho, y = Standard.Deviation , group = k, color = k)) +
  geom_line() + geom_point() + facet_wrap(~method) +
  xlab(expression(paste("Correlation, ", rho)))+
  scale_color_brewer(palette="RdYlBu")
b
```

**Supplementary Figure 4** Standard deviation from matching estimators when overlap between treated and control individuals is poor.  Simulations were carried out as described in Section 4.1, but with $\phi(X_i) = X_{i1} - 10/3$.  This kept the sample size and number of treated individuals constant while increasing the separation of treated and control individuals.


# Supplementary Figure 5

```{r}
dat <- lapply(1:10, function(x) read_data_1000(x, "../data/tuning/sigma_2/nsim_1000/")) %>% bind_rows()
```

```{r}
true_tau <- 1

dat <- dat %>% mutate(
              squared_err = (estimate-true_tau)**2,
              k = as.factor(k))

plt_data <- dat %>%
  group_by(method, k, rho) %>% 
  summarize(Bias = abs(mean(estimate) - true_tau), 
            median_gamma = median(gamma), 
            Standard.Deviation = sd(estimate),
            MSE = Bias^2 + Standard.Deviation^2) %>%
  ungroup() %>%
  mutate(method = recode(method, propensity = "Propensity", 
                         mahalanobis = "Mahalanobis", 
                         prognostic = "Buffalo"))
```

```{r, echo = FALSE}
plt_data <- plt_data %>%
  mutate(method = factor(method, levels = c("Mahalanobis", "Propensity", "Buffalo")))
```

```{r, fig.width=8.5, fig.height=6, echo = FALSE}
a <- ggplot(plt_data, aes(x = rho, y = Bias, group = k, color = k)) +
  geom_line() + geom_point() +
  xlab(expression(paste("Correlation, ", rho)))+
  facet_wrap(~method) +
  scale_color_brewer(palette="RdYlBu")

b <- ggplot(plt_data, aes(x = rho, y = Standard.Deviation, group = k, color = k)) +
  geom_line() + geom_point() + facet_wrap(~method) +
  xlab(expression(paste("Correlation, ", rho)))+
  scale_color_brewer(palette="RdYlBu")

c <- ggplot(plt_data, aes(x = rho, y = MSE, group = k, color = k)) +
  geom_line() + geom_point() + 
  xlab(expression(paste("Correlation, ", rho)))+
  facet_wrap(~method)+
  scale_color_brewer(palette="RdYlBu")

d <- ggplot(plt_data, aes(x = rho, y = median_gamma, group = k, color = k)) +
  geom_line() + geom_point() +
  ylab(expression(paste("Median ", Gamma))) +
  xlab(expression(paste("Correlation, ", rho)))+
  facet_wrap(~method) + 
  scale_color_brewer(palette="RdYlBu")

ggarrange(c, d, ncol = 1, nrow = 2, common.legend = TRUE, legend = "right", labels = "AUTO")

```

**Supplementary Figure 5** MSE and median gamma design sensitivity when the random noise contributing to the outcome is increased.  All simulation parameters are the same as described in Section 4.1, except that $\sigma = 2$ This increases the difficulty of fitting the prognostic score, diminishing the performance of Buffalo matching in terms of MSE and sensitivity.